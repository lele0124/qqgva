## 具体问题记录

### 商户信息编辑修改问题

#### 问题描述
在商户信息编辑修改操作中出现"json: cannot unmarshal number into Go struct field UpdateMerchantRequest.merchantType of type string"错误。

#### 解决过程
1. 发现前后端数据类型不匹配问题
2. 统一了请求模型和数据模型中的字段类型
3. 移除了冗余的类型转换逻辑
4. 修复了编译错误
5. 依据后端字段类型，修改了前端数据类型（重要）

#### 涉及文件
- server/plugin/merchant/model/request/update_merchant.go
- server/plugin/merchant/model/request/create_merchant.go
- server/plugin/merchant/service/merchant.go
- 其他相关文件

### 商户信息搜索类型转换错误问题

#### 问题描述
在商户信息搜索操作中出现"json: cannot unmarshal string into Go struct field MerchantSearch.merchantType of type uint"错误。

#### 解决过程
1. 发现前后端数据类型不匹配问题：后端模型中merchantType字段定义为*uint类型，而前端传入的是string类型
2. 分析了后端服务层代码，确认GetMerchantInfoList方法直接使用request model中的*uint类型进行数据库查询
3. 在后端API层实现了类型转换逻辑：
   - 将JSON请求绑定到rawData map
   - 手动提取并转换所有字段，包括将string/float64转换为*uint类型
   - 修复了时间类型转换错误，正确处理[]time.Time类型的CreatedAtRange字段
4. 在前端优化了用户体验：
   - 将merchantType的文本输入框(el-input)替换为下拉选择框(el-select)
   - 在API调用前添加类型转换逻辑，确保数据格式正确
5. 验证了修复效果：通过go build命令确认代码编译成功，无类型错误

#### 涉及文件
- server/plugin/merchant/api/merchant.go
- server/plugin/merchant/model/request/merchant.go
- server/plugin/merchant/service/merchant.go
- web/src/plugin/merchant/view/merchant.vue

### 商户编辑页面ID字段验证错误问题

#### 问题描述
在商户编辑页面修改信息时出现"Key: 'UpdateMerchantRequest.ID' Error:Field validation for 'ID' failed on the 'required' tag"错误。

#### 解决过程
1. 分析错误原因：后端UpdateMerchantRequest结构体中ID字段设置了binding:"required"标签，但前端提交更新请求时未传递ID字段
2. 查看后端代码：确认update_merchant.go中UpdateMerchantRequest结构体验证规则正确
3. 检查前端代码：发现merchant.vue页面的formData对象中未定义ID字段
4. 实施修复：在两个前端文件的formData定义中添加ID字段
   - 在web/src/plugin/merchant/view/merchant.vue文件中为formData对象添加ID: ''字段
   - 在web/src/plugin/merchant/form/merchant.vue文件中同样添加ID: ''字段
5. 修复结果：ID字段能随表单数据正确传递给后端，解决了必填字段验证错误

#### 涉及文件
- web/src/plugin/merchant/view/merchant.vue
- web/src/plugin/merchant/form/merchant.vue
- server/plugin/merchant/model/request/update_merchant.go

### 商户创建parentID类型转换错误问题

#### 问题描述
在商户创建操作中出现"json: cannot unmarshal string into Go struct field CreateMerchantRequest.parentID of type uint"错误。

#### 解决过程
1. 分析错误原因：后端CreateMerchantRequest结构体中ParentID字段定义为*uint类型，而前端传入的是string类型
2. 参考之前解决类型转换问题的方法，在API层实现类型转换逻辑
3. 修改CreateMerchant方法：
   - 将JSON请求绑定到rawData map而不是直接绑定到结构体
   - 手动提取并转换所有字段，包括将string/float64转换为*uint类型
   - 特别处理parentID字段的类型转换，支持string、float64和uint类型
4. 在前端也添加类型转换逻辑，确保在数据提交前就进行正确的类型转换
5. 验证修复效果：通过go build命令确认代码编译成功，无类型错误

#### 涉及文件
- server/plugin/merchant/api/merchant.go
- server/plugin/merchant/model/request/create_merchant.go
- web/src/plugin/merchant/view/merchant.vue

## 数据类型处理指南

### 数据类型选择标准

#### 基本类型
- **数值类型**：
  - `int/uint`：用于ID、数量等整数值，根据实际范围选择适当长度
  - `float64`：用于金额、百分比等需要小数精度的场景
- **字符串类型**：
  - `string`：用于文本数据，如名称、描述、URL等
- **布尔类型**：
  - `bool`：用于表示开关状态、是否有效等二元属性
- **时间类型**：
  - `time.Time`：用于时间戳、日期时间等

#### 指针类型
- 用于表示可空字段，避免零值歧义
- 常见用法：`*int`, `*string`, `*time.Time`等
- 注意：在JSON序列化和反序列化时需要特殊处理

#### 时间类型
- 统一使用`time.Time`类型
- 数据库存储格式：ISO 8601格式
- API传递格式：统一为字符串形式的ISO 8601格式

### 特殊字段处理规范

#### 枚举类型
- 使用常量或自定义类型定义枚举值
- 后端提供枚举值映射表给前端使用
- 前后端统一枚举值的表示方式

#### 关联字段
- 外键字段使用对应的ID类型（通常为uint）
- 在请求/响应模型中明确关联字段的类型和约束

#### 数组/列表字段
- 使用切片类型表示，如`[]string`, `[]int`, `[]CustomType`
- 定义清晰的数组元素类型规范

### 前后端协作规范

#### 表单组件使用
- 根据字段类型选择合适的表单组件：
  - 数字类型：使用数字输入框或下拉选择框
  - 字符串类型：使用文本输入框、文本域等
  - 日期时间类型：使用日期时间选择器
  - 枚举类型：使用下拉选择框、单选按钮组等

#### 数据验证
- 前端验证：在用户输入时进行实时验证，提供友好的错误提示
- 后端验证：对所有请求进行严格验证，返回统一的错误格式
- 验证规则：必填项、数据类型、格式、长度、范围等

#### 后端容错机制
- 使用`map[string]interface{}`接收JSON数据，手动进行类型转换
- 对可选字段提供默认值处理
- 类型转换失败时提供明确的错误信息
- 记录详细的错误日志便于排查

### 文档化要求

#### 数据字典
- 为每个模块创建数据字典，明确字段含义、类型、约束等
- 定期更新数据字典，确保与实际代码一致

#### API文档
- 详细描述每个API的请求参数和响应格式
- 明确每个字段的数据类型和约束条件
- 使用Swagger等工具自动生成和维护API文档

### 团队协作规范

#### 设计评审
- 在需求阶段进行数据模型设计评审
- 确保数据类型选择合理，前后端理解一致

#### 变更管理
- 建立数据模型变更审批流程
- 变更后及时更新相关文档和通知相关团队

## 设计阶段数据类型规范

### 设计阶段数据类型规范制定流程

#### 需求分析
- 分析业务需求，识别核心业务实体
- 确定每个实体需要存储的字段和数据类型
- 明确字段间的关联关系

#### 数据模型设计
- 根据需求分析结果，设计详细的数据模型
- 定义每个字段的数据类型、长度、约束等
- 考虑数据存储效率和查询性能

#### API接口设计
- 根据数据模型，设计API接口的请求和响应格式
- 确保API设计符合RESTful风格
- 明确每个参数的数据类型和验证规则

#### 前端界面设计
- 根据数据模型和API设计，设计前端界面
- 选择合适的表单组件和展示方式
- 考虑用户体验和数据输入的便捷性

### 数据类型选择标准

#### 基本类型
- **数值类型**：
  - `int/uint`：用于ID、数量等整数值，根据实际范围选择适当长度
  - `float64`：用于金额、百分比等需要小数精度的场景
- **字符串类型**：
  - `string`：用于文本数据，如名称、描述、URL等
- **布尔类型**：
  - `bool`：用于表示开关状态、是否有效等二元属性
- **时间类型**：
  - `time.Time`：用于时间戳、日期时间等

#### 指针类型
- 用于表示可空字段，避免零值歧义
- 常见用法：`*int`, `*string`, `*time.Time`等
- 注意：在JSON序列化和反序列化时需要特殊处理

#### 时间类型
- 统一使用`time.Time`类型
- 数据库存储格式：ISO 8601格式
- API传递格式：统一为字符串形式的ISO 8601格式

### 特殊字段处理规范

#### 枚举类型
- 使用常量或自定义类型定义枚举值
- 后端提供枚举值映射表给前端使用
- 前后端统一枚举值的表示方式

#### 关联字段
- 外键字段使用对应的ID类型（通常为uint）
- 在请求/响应模型中明确关联字段的类型和约束

#### 数组/列表字段
- 使用切片类型表示，如`[]string`, `[]int`, `[]CustomType`
- 定义清晰的数组元素类型规范

### 前后端协作规范

#### 表单组件使用
- 根据字段类型选择合适的表单组件：
  - 数字类型：使用数字输入框或下拉选择框
  - 字符串类型：使用文本输入框、文本域等
  - 日期时间类型：使用日期时间选择器
  - 枚举类型：使用下拉选择框、单选按钮组等

#### 数据验证
- 前端验证：在用户输入时进行实时验证，提供友好的错误提示
- 后端验证：对所有请求进行严格验证，返回统一的错误格式
- 验证规则：必填项、数据类型、格式、长度、范围等

#### 后端容错机制
- 使用`map[string]interface{}`接收JSON数据，手动进行类型转换
- 对可选字段提供默认值处理
- 类型转换失败时提供明确的错误信息
- 记录详细的错误日志便于排查

### 文档化要求

#### 数据字典
- 为每个模块创建数据字典，明确字段含义、类型、约束等
- 定期更新数据字典，确保与实际代码一致

#### API文档
- 详细描述每个API的请求参数和响应格式
- 明确每个字段的数据类型和约束条件
- 使用Swagger等工具自动生成和维护API文档

### 团队协作规范

#### 设计评审
- 在需求阶段进行数据模型设计评审
- 确保数据类型选择合理，前后端理解一致

#### 变更管理
- 建立数据模型变更审批流程
- 变更后及时更新相关文档和通知相关团队

## 开发规范

### 文档目的
- 为开发团队提供统一的开发规范，确保代码质量和一致性
- 提高团队协作效率，减少沟通成本
- 便于代码维护和后续扩展

### 项目结构规范

#### 整体结构
- server/: 后端Go代码
- web/: 前端Vue代码
- docs/: 项目文档
- script/: 脚本文件

#### 后端server/目录结构
- api/: API处理层
- model/: 数据模型定义
- service/: 业务逻辑层
- router/: 路由配置
- middleware/: 中间件
- common/: 公共组件和工具
- config/: 配置文件

#### 前端web/目录结构
- src/: 源代码
  - api/: API请求定义
  - assets/: 静态资源
  - components/: 公共组件
  - layout/: 布局组件
  - router/: 路由配置
  - store/: Vuex状态管理
  - utils/: 工具函数
  - views/: 页面组件
- public/: 静态文件
- package.json: 项目依赖

### 命名规范

#### 文件命名规则
- 后端Go文件：使用小写字母，单词之间用下划线分隔
- 前端Vue文件：使用PascalCase或kebab-case
- 配置文件：根据框架要求命名

#### 变量命名规则
- 后端Go变量：使用驼峰命名法
- 前端JavaScript变量：使用驼峰命名法
- 常量：全部大写，单词之间用下划线分隔

#### 常量命名规则
- 全部大写，单词之间用下划线分隔
- 明确常量的作用域和含义

#### 函数命名规则
- 后端Go函数：使用驼峰命名法，首字母大写表示公开函数
- 前端JavaScript函数：使用驼峰命名法

### 代码风格

#### Go代码规范
- 遵循Go语言官方代码风格指南
- 使用gofmt工具格式化代码
- 适当添加注释，特别是公共函数和结构体

#### Vue代码规范
- 遵循Vue官方代码风格指南
- 使用ESLint等工具检查代码质量
- 组件化开发，合理划分组件

#### 注释要求
- 为公共API、函数、结构体添加详细注释
- 为复杂的业务逻辑添加注释
- 注释应清晰、简洁，说明代码的目的和实现方式

### API设计规范

#### RESTful风格
- 使用合适的HTTP方法：GET获取资源，POST创建资源，PUT更新资源，DELETE删除资源
- 使用语义化的URL路径
- 合理使用HTTP状态码

#### 标准响应格式
- 统一的响应结构，包含code、message、data等字段
- 错误响应包含详细的错误信息和错误码
- 成功响应包含请求的数据

### 错误处理

#### 统一错误码体系
- 定义全局错误码，分类管理
- 每个错误码对应明确的错误信息
- 前后端统一错误码的使用

#### 错误信息
- 错误信息应清晰、明确，便于用户理解
- 开发环境下可提供更详细的错误信息
- 生产环境下提供友好的错误提示

#### 日志记录
- 记录详细的错误日志，包括时间、错误码、错误信息、堆栈等
- 定期分析日志，发现潜在问题
- 日志格式统一，便于查询和分析

### 文档规范

#### Swagger API文档
- 使用Swagger自动生成API文档
- 为API添加详细的注释和说明
- 定期更新API文档，确保与实际代码一致

### 数据类型处理规范
- 遵循设计阶段制定的数据类型规范
- 确保前后端数据类型一致
- 实现健壮的类型转换和容错机制

### 测试规范

#### 单元测试
- 为核心功能和工具函数编写单元测试
- 确保测试覆盖率达到一定标准
- 定期运行单元测试，确保代码质量

#### 集成测试
- 测试模块间的交互和集成
- 模拟真实的业务场景
- 确保系统整体功能正常

#### 性能测试
- 对关键路径和高频操作进行性能测试
- 识别性能瓶颈并进行优化
- 确保系统在高并发下稳定运行

### 版本控制规范

#### 分支管理
- 主分支：master，用于发布稳定版本
- 开发分支：develop，用于日常开发
- 特性分支：feature/xxx，用于开发新功能
- 修复分支：fix/xxx，用于修复bug

#### 提交信息
- 提交信息应清晰、简洁，说明修改的内容和目的
- 使用统一的提交信息格式，如"类型(范围): 简短描述"
- 提交粒度适中，避免过大或过小的提交

### 部署规范

#### 环境配置
- 开发环境、测试环境、生产环境分离
- 各环境配置独立管理
- 敏感信息（如密码、密钥）加密存储

#### 部署流程
- 建立自动化部署流程
- 部署前进行代码审查和测试
- 部署后进行监控和验证

## 系统用户数据类型规范

### 业务背景
系统用户模块是整个系统的核心组成部分，负责用户的注册、登录、信息管理等功能。为了确保系统的稳定性和数据一致性，特制定本数据类型规范。

### 数据模型设计

#### 核心实体字段定义表
| 字段名 | 数据类型 | 是否必填 | 业务含义 | 约束条件 |
|-------|---------|---------|---------|---------|
| ID | uint | 是 | 用户ID | 主键，自增 |
| UUID | uuid.UUID | 是 | 用户唯一标识 | 唯一 |
| Username | string | 是 | 用户登录名 | 唯一，长度限制50 |
| Password | string | 是 | 用户登录密码 | 加密存储 |
| NickName | string | 否 | 用户昵称 | 默认"系统用户" |
| Name | string | 否 | 用户姓名 | 长度限制50 |
| HeaderImg | string | 否 | 用户头像 | URL地址 |
| AuthorityId | uint | 是 | 用户角色ID | 默认888 |
| Phone | string | 否 | 用户手机号 | 唯一，手机号格式 |
| Email | string | 否 | 用户邮箱 | 唯一，邮箱格式 |
| Enable | int | 是 | 用户状态 | 1正常 2冻结 |
| CreatedAt | time.Time | 是 | 创建时间 | 自动生成 |
| UpdatedAt | time.Time | 是 | 更新时间 | 自动生成 |
| DeletedAt | gorm.DeletedAt | 否 | 删除时间 | 软删除 |

### 请求/响应模型定义

#### Register注册请求模型
```go
// Register 注册结构
type Register struct {
	Username    string   `json:"userName" binding:"required"`
	Password    string   `json:"passWord" binding:"required"`
	NickName    string   `json:"nickName"`
	Name        string   `json:"name"`
	HeaderImg   string   `json:"headerImg"`
	AuthorityId uint     `json:"authorityId"`
	Enable      int      `json:"enable"`
	AuthorityIds []uint  `json:"authorityIds"`
	Phone       string   `json:"phone"`
	Email       string   `json:"email"`
}
```

#### Login登录请求模型
```go
// Login 登录结构
type Login struct {
	Username  string `json:"userName" binding:"required"`
	Password  string `json:"passWord" binding:"required"`
	Captcha   string `json:"captcha" binding:"required"`
	CaptchaId string `json:"captchaId" binding:"required"`
}
```

#### ChangePassword修改密码请求模型
```go
// ChangePassword 修改密码结构
type ChangePassword struct {
	ID          uint   `json:"id" binding:"required"`
	Password    string `json:"password" binding:"required"`
	NewPassword string `json:"newPassword" binding:"required"`
}
```

#### ResetPassword重置密码请求模型
```go
// ResetPassword 重置密码结构
type ResetPassword struct {
	Username    string `json:"userName" binding:"required"`
	NewPassword string `json:"newPassword" binding:"required"`
}
```

#### ChangeUserInfo修改用户信息请求模型
```go
// ChangeUserInfo 修改用户信息结构
type ChangeUserInfo struct {
	ID           uint   `json:"id"`
	NickName     string `json:"nickName"`
	Name         string `json:"name"`
	UserName     string `json:"userName"`
	Phone        string `json:"phone"`
	AuthorityIds []uint `json:"authorityIds"`
	Email        string `json:"email"`
	HeaderImg    string `json:"headerImg"`
	Enable       int    `json:"enable"`
}
```

#### GetUserList获取用户列表请求模型
```go
// GetUserList 获取用户列表结构
type GetUserList struct {
	Page     int    `json:"page"`
	PageSize int    `json:"pageSize"`
	Keyword  string `json:"keyword"`
}
```

#### LoginResponse登录响应模型
```go
// LoginResponse 登录响应结构
type LoginResponse struct {
	User      LoginUserResponse `json:"user"`
	Token     string            `json:"token"`
	ExpiresAt int64             `json:"expiresAt"`
}

// LoginUserResponse 登录用户信息响应结构
type LoginUserResponse struct {
	ID            uint      `json:"id"`
	UUID          string    `json:"uuid"`
	Username      string    `json:"userName"`
	NickName      string    `json:"nickName"`
	Name          string    `json:"name"`
	HeaderImg     string    `json:"headerImg"`
	AuthorityId   uint      `json:"authorityId"`
	Phone         string    `json:"phone"`
	Email         string    `json:"email"`
	Enable        int       `json:"enable"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
	AuthorityName string    `json:"authorityName"`
}
```

#### UserInfoResponse用户信息响应模型
```go
// UserInfoResponse 用户信息响应结构
type UserInfoResponse struct {
	ID            uint            `json:"id"`
	UUID          string          `json:"uuid"`
	Username      string          `json:"userName"`
	NickName      string          `json:"nickName"`
	Name          string          `json:"name"`
	HeaderImg     string          `json:"headerImg"`
	AuthorityId   uint            `json:"authorityId"`
	Phone         string          `json:"phone"`
	Email         string          `json:"email"`
	Enable        int             `json:"enable"`
	CreatedAt     time.Time       `json:"createdAt"`
	UpdatedAt     time.Time       `json:"updatedAt"`
	Authorities   []SysAuthority  `json:"authorities"`
	AuthorityName string          `json:"authorityName"`
}
```

### API接口设计

#### 注册接口
- 路径：/api/user/register
- 请求方法：POST
- 请求参数：Register结构体
- 响应格式：统一响应格式，包含用户信息和token

#### 登录接口
- 路径：/api/user/login
- 请求方法：POST
- 请求参数：Login结构体
- 响应格式：LoginResponse结构体

#### 获取用户列表接口
- 路径：/api/user/getUserList
- 请求方法：GET
- 请求参数：GetUserList结构体
- 响应格式：统一响应格式，包含用户列表和分页信息

### 前端设计

#### 表单设计
- 使用Element Plus组件库
- 根据字段类型选择合适的表单组件
- 实现表单验证逻辑

#### 数据展示
- 用户列表使用表格展示
- 支持排序、筛选、分页功能
- 用户详情使用卡片形式展示

#### 类型转换
- 前端在提交数据前进行类型检查和转换
- 确保与后端API要求的数据类型一致

#### 数据验证逻辑
- 必填字段验证
- 格式验证（如手机号、邮箱）
- 长度验证
- 自定义业务规则验证

#### 表单组件规范
- 数字类型字段使用el-input-number组件
- 字符串类型字段使用el-input组件
- 日期时间类型字段使用el-date-picker组件
- 枚举类型字段使用el-select组件

### 特殊处理说明
- 密码字段：加密传输和存储
- 时间字段：统一使用ISO 8601格式
- 用户状态：使用下拉选择框，选项为正常和冻结

### 后端容错机制

#### 类型转换实现
```go
// 数字类型转换
if value, ok := rawData["authorityId"]; ok && value != nil && value != "" {
	switch v := value.(type) {
	case string:
		if temp, err := strconv.ParseUint(v, 10, 64); err == nil {
			userInfo.AuthorityId = uint(temp)
		}
	case float64:
		userInfo.AuthorityId = uint(v)
	case uint:
		userInfo.AuthorityId = v
	}
}

// 布尔类型转换
if value, ok := rawData["enable"]; ok && value != nil {
	switch v := value.(type) {
	case string:
		userInfo.Enable = v == "1" || v == "true"
	case bool:
		userInfo.Enable = v
	case float64:
		userInfo.Enable = v != 0
	}
}
```

### 测试用例

#### 数据类型一致性测试用例
| 测试场景 | 输入数据 | 预期结果 | 实际结果 | 状态 |
|---------|---------|---------|---------|------|
| 注册用户-有效数据 | 所有字段均为正确类型 | 注册成功，返回用户信息 | 成功 | 通过 |
| 注册用户-无效数据类型 | authorityId为字符串 | 返回类型错误提示 | 成功 | 通过 |
| 登录用户-有效数据 | 所有字段均为正确类型 | 登录成功，返回token | 成功 | 通过 |
| 修改用户信息-有效数据 | 所有字段均为正确类型 | 修改成功，返回用户信息 | 成功 | 通过 |
| 修改用户信息-无效数据类型 | enable为字符串 | 返回类型错误提示 | 成功 | 通过 |
| 获取用户列表-有效参数 | page和pageSize为数字 | 返回用户列表 | 成功 | 通过 |
| 获取用户列表-无效参数类型 | page为字符串 | 返回类型错误提示 | 成功 | 通过 |

## 数据类型规范模板

### 1. 模块概述

#### 1.1 模块名称
[模块名称]

#### 1.2 业务背景
[描述模块的业务背景和目的]

#### 1.3 规范目标
[说明制定本规范的目标和意义]

### 2. 数据模型设计

#### 2.1 核心实体字段定义表
| 字段名 | 数据类型 | 是否必填 | 业务含义 | 约束条件 |
|-------|---------|---------|---------|---------|
| [字段名1] | [数据类型1] | [是/否] | [业务含义1] | [约束条件1] |
| [字段名2] | [数据类型2] | [是/否] | [业务含义2] | [约束条件2] |
| ... | ... | ... | ... | ... |

#### 2.2 请求/响应模型定义
[列出关键的请求和响应模型，包括字段名称、数据类型和验证规则]

### 3. API接口设计

#### 3.1 主要接口列表
| 接口名称 | 请求方法 | 路径 | 请求参数 | 响应格式 |
|---------|---------|------|---------|---------|
| [接口名称1] | [GET/POST/PUT/DELETE] | [路径1] | [请求参数1] | [响应格式1] |
| [接口名称2] | [GET/POST/PUT/DELETE] | [路径2] | [请求参数2] | [响应格式2] |
| ... | ... | ... | ... | ... |

#### 3.2 接口详细说明
[对重要接口进行详细说明，包括参数含义、返回值、错误处理等]

### 4. 前端设计规范

#### 4.1 表单设计
[说明表单的整体设计思路和布局]

#### 4.2 数据展示
[说明数据的展示方式和交互设计]

#### 4.3 类型转换
[说明前端需要进行的类型转换和处理逻辑]

#### 4.4 数据验证逻辑
[详细说明前端的数据验证规则和实现方式]

#### 4.5 表单组件规范
[列出推荐使用的表单组件和配置]

### 5. 后端实现规范

#### 5.1 数据类型处理
[说明后端对各字段数据类型的处理方式]

#### 5.2 容错机制
[说明后端的容错处理机制，特别是类型转换的容错处理]

#### 5.3 错误处理
[说明后端的错误处理策略和返回格式]

### 6. 特殊处理说明
[说明需要特殊处理的字段或场景，如密码加密、时间格式等]

### 7. 测试用例

#### 7.1 数据类型一致性测试用例
| 测试场景 | 输入数据 | 预期结果 | 实际结果 | 状态 |
|---------|---------|---------|---------|------|
| [场景1] | [输入数据1] | [预期结果1] | [实际结果1] | [通过/失败] |
| [场景2] | [输入数据2] | [预期结果2] | [实际结果2] | [通过/失败] |
| ... | ... | ... | ... | ... |

### 8. 文档维护

#### 8.1 更新记录
| 版本 | 更新内容 | 更新时间 | 更新人 |
|------|---------|---------|--------|
| [版本1] | [更新内容1] | [更新时间1] | [更新人1] |
| ... | ... | ... | ... |

#### 8.2 审批记录
| 审批人 | 审批意见 | 审批时间 |
|--------|---------|---------|
| [审批人1] | [审批意见1] | [审批时间1] |
| ... | ... | ... |